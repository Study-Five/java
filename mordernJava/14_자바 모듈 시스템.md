## 14.1 압력 : 소프트웨어 유추 

### 14.1.1 관심사 분리 

- 관심사 분리 : 컴퓨터 프로그램을 고유의 기능으로 나누는 동작을 권장하는 원칙
- 그룹화한 모듈을 이용해 애플리케이션의 클래스간의 관계를 시간적으로 보여줄 수 있음
- SoC 원칙 
  - 개별기능을 따로 작업할 수 있으므로 팀이 쉽게 협업 가능
  - 개별부분을 재사용 쉬움
  - 전체시스템을 쉽게 유지보수 가능 

### 14.1.2 정보은닉

- 정보은닉 : 세부 구현을 숨기도록 장력하는 원칙
- 캡슐화 : 특정 코드 조각이 애플리케이션의 다른 부분과 고립됨. 내부적 변화가 외부에 영향 미칠 가능성 줄어듬
- 자바9전엔 클래스와 패키지가 의도된 대로 공개되었는지 컴파일러로 확인 불가(private)

### 14.1.3 자바 소프트웨어 

- UML을 그려 코드간 의존성 시각적 제시 가능 
- 접근제한자와 패키지 수준 접근 권한으로 메서드, 필드 클래스 접근 제어 <- 원하는 접근제한 달성 어렵

## 14.2 자바 모듈 시스템을 설계한 이유

### 14.2.1 모듈화의 한계 

- 클래스, 패키지, JAR 세가지 수준의 코드 구룹화 제공. 클래스: 접근제한자와 캡슐화 지원. but 패키지, JAR는 거의 X

#### 제한된 가시성 제어

- 접근자 : public, protected, 패키지수준, private
- 한 패키지의 클래스와 인터페이스 다른 패키기로 공개하려면 public으로 선언해야 -> "impl" 문자열 가진 패키지에서 문제 두각 
- 보안 측면에서 코드 노출 -> 임의 조작 위험 

#### 클래스 경로 

- 클래스 모두 컴파일 -> 한캐의 평범한 JAR에 넣음 -< 클래스 경로에JAR 파일 추가해 사용 -> JVM 이 동적으로 클래스경로에 정의된 클래스를 필요할때 읽음
- 약점 
  1. 클래스 경로에 같은 클래스 구분하는 버전 개념 X. 두 버전의 같은 라이브러리 존재시 문제 발생
  2. 클래스 경로는 명시적 의존성 지원X. JAR안에 클래스는  classes라는 한 주머니로 합쳐짐. 하 JAR가 다른JAR에 포함된 클래스집합을 사용하라고 명시적 정의 기능 제공X.
  빠진것, 충돌 문제
     
- 빌드도구(메이븐, 그레들) 이 도움을 줌. 자바9 전에는 자바,JVM 누구도 명시적 의존성 정의 지원X
- ClassNotFoundException 안날때까지 경로에 클래스 파일 더하거나 빼보는 수 밖에 

### 14.2.2 거대한 JDK

- JDK : 자바 프로그램을 만들고 실행하는데 도움을 주는 도구의 집합. 
  - javac(컴파일), java(로드 실행), JDK라이브러리(입출력,런타임 지원), 컬렉션, 스트림...
- 점점 커지는 JDK.. 모바일, 클라우드에서 문제 
- 자바8 컴파일 프로파일 : JDK를 세가지 프로파일로 나누어 각가 다른 메모리 풋프린트 제공 -> 내부api가 공개됨
- 강력한 캡슐화를 제공하는 새 건축구조 필요

### 14.2.3 OSGi(open service gateway initiative)와 비교 

- 들어본적 없어서 패스^.^

## 14.3 자바 모듈 : 큰 그림 

- 모듈이라는 새로운 자바 프로그램 구조 단위 제공. 
- module이란 키워드에 이름과 바디를 추가해서 정의 
- 모듈 디스크립터 는 module-info.java라는 특별한 파일에 저장
- 모듈 디스크립터는 보통 패키지와 같은 폴더에 위치. 한개 이상의 패키지를 서술하고 캡슐화 할 수 있지만 단순한 상황에서는 이 패키지 중 한개만 외부로 노출 
```
  module 모듈명
  exports 패키지명 // 한 패키지를 노풀시키는 간단한 형식
  requires 모듈명 // 0개 이상의 모듈 
```
- 직소퍼즐 예시로  exports 는 돌출불, requires는 패인부분

## 14.4 자바 모듈 시스템으로 애플리케이션 개발하기 

### 14.4.1 애플리케이션 셋업 

- 여러 관심사를 분리 
  - 다양한 소스에서 데이터 읽음/ 데이터 파싱/ 도메인 객체를 구체화 / 통계 계산 및 반환 / 다양한 기능 분리 조정
- 각 기능을 그룹화 

### 14.4.2 세부적인 모듈화를 거친 모듈화 

- 세부적 보듈화 : 시스템 모듈화 시 모듈 크기 결정. 모든 패키지가 자신의 모듈 가짐 (설계비용 증가) 
- 거친 모듈화 : 한 모듈이 시스템의 모든 패키지를 호함. (모듈화 장점 잃음)
- 시스템을 실용적으로 분해하면서 진화하는 소프트웨어 프로젝트가 적절하게 모듈화 됐는지 주기적으로 확인해야. 
- 모듈화는 소프트웨어 부식의 적 

### 14.4.3 자바 모듈 시스템 기초 

- module-info.java : 모듈 디스크립터. 소스코드 파일 루트에 위치. 모듈의 의존성, 어떤 기능을 외부 노출할지 정의 
- 자바 .class 실행시 두 옵션 추가됨 
  - --module-path :  어떤 모듈을 로드할 수 있는지 지정. 이 옵션은 클래스 파일을 지정하느 --classpath인수와 다름
  - --module : 이 옵션은 실행할 메인 모듈과 클래스를 지정.
  
## 14.5 여러 모듈 활용하기 

### 14.5.1 exports 구문 

- exports: 다른 모듈에서 사용 할 수 있도록 특정 패키지를 공개형식으로 만듬. 
- 모듈내 모든것은 캡슐화 됨. 화이트리스트 기법이용해 강력한 캡슐화 제공하므로 노출할 기능 명시적으로 결정해야.

### 14.5.2 requires 구분

- requires: 의존하고 있는 모듈을 지정
- java.base 는 net, io,util 등 메인 패키지 포함함. 얘는 명시 안해도 기본 포함됨 

### 14.5.3 이름 정하기

- 오라클은 패키지명처럼 인터넷 도메인명을 역순으로 모듈의 이름을 정하도록 권고(com.iteratrlearning,training)
- 모듈명은 노출된 주요 API 패키지와 이름이 같아야함

## 14.6 컴파일과 패키징 

- 각 모듈에 pom.xml 을 추가해야. 각 모듈을 독립적 컴파일 됨 -> 각각이 자체적으로 한개의 프로젝트. 
- 명시적으로 부모모듈을 지정. pom.xml 에 지정해야. 부모는 ID expenses를 포함하는 부산물(artifact)

## 14.7 자동 모듈 

- 외부 라이브러리를 프로젝트에 추가. module-info.java에 requries 구문/ pom.xml에 추가/ 경로에 jar 추가 
- 모듈 경로상에 있으나 module-info파일 가지지 않는 모든 JAR는 자동모듈이 됨
- 자동 모듈은 암묵적으로 자신의 모든 패키지를 노출 
- 자동모듈 이름은 JAR이름을 이용해 정해짐 (--describe-module로 변경가능)

## 14.8 모듈 정의와 구문들 

- 모듈 지시어 이용해 정의 
```java
moudule com.iteratrlearning.application{
	requires com.iteratrlearning.ui;
	exports com.iteratrlearning.ui.panels;
    exports com.iteratrlearning.ui.widgets;
}
```

### 14.8.1 requires

- 컴파일 타임과 런타임에 한 모듈이 다른 모듈에 의좀함을 정의 

### 14.8.2 exports 

- 지정한 패키지를 다른 모듈에서 이용할 수 있도록 공개 형식으로 만듬. 공개않는게 디폴트. 어떤 패키지 공개할지 명시적으로 지정해 캡슐화 높힘

### 14.8.3 requires transitive

- 다른 모듈이 제공하는 공개 형식을 한 모듈에서 사용할 수 있다고 지정 
```java
moudule com.iteratrlearning.ui{
	requires transitive com.iteratrlearning.core;
	exports com.iteratrlearning.ui.panels;
    exports com.iteratrlearning.ui.widgets to com.iteratrlearning.ui.widgetuser;
}
```
- 필요로 하는 모듈(ui)이 다른 모듈(core) 형식을 반환하는 상황에서 전이성 선언을 유용하게 사용. 
- ui에 의존하는 모든 모듈은 core읽을 수 있음

### 14.8.4 export to 

- 사용자에게 공개할 기능을 제한함으로 가시성을 좀 더 정교하게 제어 

### 14.8.5 open과 opens

- open: 모든 패키지를 다른 모듈에 반사적으로 접근을 허용. 모듈의 가시성에는 영향을 미치지 않음
```java
open module com.iteratrlearning.ui{
	
}
```
- opnes 모듈선언에 이용해 필요한 개별 패키지만 개방 가능. open 에 to를 붙여 반사적 접근을 특정 모듈에만 허용도 가능

### 14.8.6 uses 와 provides

- provides 구문으로 서비스 제공자를, users 구문으로 서비스 소비자를 지정할 수 있음. 
- The Java Module System 책 보길 

## 14.9 더 큰 예제 그리고 더 배울 수 있는 방법 

- 오라클의 자바문서의 예제 
- 자바 9로 이전시 EE관련 여러 패키지가 모듈화된 자바 9 가상머신에서 로드 안됨. 호환성 유지를 위해 --add-modules명령행을 이용해 명시적 추가 필요. 