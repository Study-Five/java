## 1.1 역사의 흐름은 무엇인가? 
- 자바 8에서의 변화로 생산성 증가.  멀티코어 cpu대중화같은 하드웨어 변화.  
- 기존 자바는 코어 하나만 사용했으며 나머지 코어 사용하려면 스레드였지만
자바 8에서는 병령실행을 단순하고 새롭게 접근할 수 있음. 
- 간결한 코드, 멀티코어 프로세서의 쉬운 활용 
    + 스트림 api : 데이터베이스 질의 언어에서 고수준 언어로 원하는 동작을 표현하면, 구현(스트림 라이브러리) 에서 최적의 저수준 실행 방법을 선택하는 방식으로 동작 
    + 메서드에 코드를 전달하는 기법 : 동작파라미터화 구현 가능. 함수형 프로그래밍에서 위력 발휘
    + 인터페이스의 티폴트 메서드 
    
## 1.2 왜 아직도 자바는 변화하는가?
- 새로운 언어가 등작하면서 진화하지 않은 기존 언어는 사장.
### 1.2.1 프로그래밍 언어 생태계에서 자바의 위치

- 다수의 유용 라이브러리 가진 잘 설계된 객체지향 언어로 시작.
    + 스레드, 락 -> 동시성
    + jvm 컴파일 -> 인터넷 애플릿 프로그램의 주요언어. 임베디드 컴퓨팅 분야 장악
    + 캠술화 -> 소프트웨어 엔지니어링 공수 적음/ 객체지향 -> WIMP프로그래밍 모델에 대응
  
- 변화의 바람 : 빅데이터 -> 병렬 프로세싱 필요 -> 대응 부족
- 자바 8 : 쉬운 유지보수, 병령성 활용, 간결한 코드

### 1.2.2 스트림 처리 

- 스트림 : 한번에 한개씩 만들어지는 연속적인 데이터 항목들의 모임
- java.util.stream Stream<T> : T형식으로 구성된 일련의 항목. 조립라인처럼 어떤 항목을 연속으로 제공하는 기능.
- 작업을 고수준으로 추상화 해서 일련의 스트림으로 만들어 처리 가능. 스트림 파이프라인으로 입력 부분을 여러 cpu코어에 쉽게 할당 가능
- 스레드라는 복잡한 작업 사용않고 공자 병렬성 

### 1.2.3 동작파라미터화로 메서드에 코드 전달하기 

- 메서드(코드) 를 다른 메서드의 인수로 넘겨주는 기능 -> 동작파라미터화 
- 연산의 동작을 파라미터화 할 수 있다.

### 1.2.4병렬성과 공유 가변 데이터 

- 병렬성을 공짜로 얻을수 있다. 대신 코드 동작 방식 변경 필요. 
- 다른 코드와 동시에 실행하더라도 안전하게 실행가능한 코드 만드려면 공유된 가변 데이터에 접근 않아야. \
  순수함수, 부작용 없는 함수, 상태없는 함수 
- 두 프로세스가 공유된 변수를 동시에 바꾸려 하면? 기존처럼 synchronized이용해 가변데이터 보호 규칙 생성 가능(시스템성능 나쁨)\
  스트림 으로 스레드보다 쉬운 병렬성 
  
- 공유되지 않은 가변데이터, 메서드, 함수코드를 다른 메서드로 전달하는 두 기능은 **함수형 프로그래밍** 의 핵심
### 1.2.5 자바가 진화해야 하는 이유 

- 지금까지 제너릭이나 List<String> 변화에 도 당화하다 편리함 누림
- ex )  Iterator 대신 for-each \
 함수형 프로그래밍 : 작업이 최우선, 수행은 별개의 문제. 전통적인 객체지향과 상극
- 언어는 하드웨어나 프로그래머의 기대의 변화에 부응하는 방향으로 변화해야. 

## 1.3 자바함수 

- 함수 : 메서드 특히 정적 메서드 의미로 사용. 자바는 이에 더해 수학적인 함수처럼 사용. 부작용을 일으키지 않는 함수 \
자바 8에서 함수를 새오운 값의 형식으로 추가. 스트림과 연계 가능하게 하기 위해. 함수를 값처럼 취급
  
- 자바에서 조작할 수 있는 값 \
기본값 : int, double.. \
  객체(객체참조) : new , String, new Integer(111) , new HashMap<Integer,String>(100) 
- 프로그래밍 언어의 핵심은 값을 바꾸는것이고, 이 값을 일급값(일급시민) 이라 부름 \
값의 구조를 표현하는데 다양한 구조체(메서드,클래스) 가 있지만 전달 불가 -> 이급시민 \
- 이급시민을 일급시민으로 만들자!

##1.3.1 메서드와 람다를 일급시민으로 

- 메서드 참조 
``` java 
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```
isHidden이라는 함수가 준비 되있으니, 메서드 참조 :: (이 메서드를 참조해랏) 이용해 listFiles에 직접 전달 

- 람다 : 익명함수 
  (기명)메서드를 일급값 취급 뿐 아니라 람다(익명함수) 포함한 함수도 값으로 취급\
```java
(int x) -> x+1; // x 라는 입수를 호출하면 x+1 을 반환 
```
### 1.3.2 코드넘겨주기 :예제 

- 필터 : 특정항목을 선택해서 반환하는 동작 
```java
  public static List<Apple> filterApples(List<Apple> inventory, Predicate<Apple> p) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
      if (p.test(apple)) {
        result.add(apple);
      }
    }
    return result;
  }

List<Apple> greenApples = filterApples(inventory, FilteringApples::isGreenApple);
```
> predicate : 인수로 값을 받아 ture 나 false 를 반환하는 함수 

### 1.3.3 메서드전달에서 람다로 

- 한두번만 사용할 메서드 정의 귀찮 -> 람다로 
```java
List<Apple> greenApples2 = filterApples(inventory, (Apple a) -> "green".equals(a.getColor()));
```

## 1.4 스트림

- 거의 모든 자바 애플리케이션은 컬렉션을 만들고 활용. \
스트림 api 이용해 컬렉션 api와는 다른방법으로 처리 가능.
- 외부반복 : for each 루프 이용해 각 요서 반복하며 작업 수행 \
내부반복 : 스트림 api 라이브러리 내부에서 모든 데이터 처리됨.

### 1.4.1 멀티스레딩은 어렵다.

- 자주 반복되는 패턴으로 주어진 조건에 따라 데이터를 필터링 \
데이터 추출 \
데이터 그룹화 
- 컬렉션은 데이터 저장, 접근에 중점 / 스트림은 데이터에 어떤 계한을 할것인지 묘사에 중점
- 스트림 내 요소 쉽게 병렬 처리 할수 있게 환경 제공 

## 1.5 디폴트 메서드와 자바 모듈

- 패키지 모음 포함하는 모듈 정의 -> JAR 같은 컴포넌트 구조 적응, 문서화, 모듈확인 작업 용이 
- 인터페이스를 쉽게 바꿀수 있도록 디폴드 메서드 지원. 미래에 프로그램이 쉽게 변화 할 수 있는 환경 제공 기능\
구현클래스에 구현안해도 되는 메서드를 인터페이스에 추가 -> 디폴트 메서드 \
  List 에 sort가 디폴트메서드라 직접 호출 가능 
- 어느정도 다중상속 가능 -> 다이아몬드 상송문제 회피법 9장~

## 1.6 함수형 프로그래밍에서 가조온 다른 유용한 아이디어 

- null 회피 : Optional<T> . NullPointer예외 피할 수 있음. 
- 구조적 패턴 매칭 : 다형성, 메서드 오버라이딩 이용해 if-then-else 대신하는 비교문 가능 



  
