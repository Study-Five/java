## 5.1 필터링

### 5.1.1 프레디케이트로 필터링 

- filter 메서드 : 프레디케이트를 인수로 받아 일치하는 모든 요소를 포함하는 스트림을 반환. 
```java
    List<Dish> vegetarianMenu = menu.stream()
        .filter(Dish::isVegetarian)
        .collect(toList());
```

### 5.1.2 고유 요소 필터링

- distinct : 고유요소로 이루어진 스트림 반환 (hashCode, equals로 결정)
```java
    List<Integer> numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);
    numbers.stream()
        .filter(i -> i % 2 == 0)
        .distinct()
```
## 5.2 스트림 슬라이싱 

- 스트림의 요 소를 선택하거나 스킵하는 다양한 방법. 
```java
    List<Dish> specialMenu = Arrays.asList(
        new Dish("season fruit", true, 120, Dish.Type.OTHER),
        new Dish("prawns", false, 300, Dish.Type.FISH),
        new Dish("rice", true, 350, Dish.Type.OTHER),
        new Dish("chicken", false, 400, Dish.Type.MEAT),
        new Dish("french fries", true, 530, Dish.Type.OTHER));
```
### 5.2.1 프레디케이트를 이용한 슬라이싱 

- TAKEWHILE활용 
- 리스트가 이미 정렬돼있다는 사실을 이용해 320보다 크면 반복작업을 중단 -> 큰 스트림에서 효율적
```java
    List<Dish> slicedMenu1 = specialMenu.stream()
        .takeWhile(dish -> dish.getCalories() < 320)
        .collect(toList());
```

- DROPWHILE 활용 
- 320보다 큰 요소 탐색 
```java
    List<Dish> slicedMenu2 = specialMenu.stream()
        .dropWhile(dish -> dish.getCalories() < 320)
        .collect(toList());
```
- 프레디케이트가 처음으로 거짓이 되는 지점까지 발견된 요소를 버림. 거짓되는 지점에서 작업 중단 후 남은 요소 반환.

### 5.2.2 스트림 축소 

- limit(n) : 주어진 값 이하의 크기를 갖는 새로운 스트림 반환
- 정렬되지 않은 스트림에도 사용가능 -> 정렬안된 상태로 반환
```java
    List<Dish> dishesLimit3 = menu.stream()
        .filter(d -> d.getCalories() > 300)
        .limit(3)
        .collect(toList());
```
### 5.2.3 요소 건너뛰기

- skip(n) : 처음n개 요소를 제외한 스트림을 반환 
- n개 이하 스트림에 호출하면 빈 스트림 반환됨. 
```java
    List<Dish> dishesSkip2 = menu.stream()
        .filter(d -> d.getCalories() > 300)
        .skip(2)
        .collect(toList());
```

## 5.3 매핑

- 특정 객체에서 특정 데이터 선택 기능

### 5.3.1 스트림의 각 요소에 함수 적용하기 

- map : 함수를 인수로 받아 각 요소에 적용 되서 새로운 요소 매핑된 결과 반환.
```java
    List<String> dishNames = menu.stream()
        .map(Dish::getName)
        .collect(toList()); //- getName()은 String 반환하므로 Stream<String> 형식 갖음. 

	List<String> dishNames = menu.stream()
	.map(Dish::getName)
        .map(String::length) // 다른 map을 연결 가능 
	.collect(toList());

```

### 5.3.2 스트림 평면화

- 리스트에서 고유문자로 이루어진 리스트 반환하고 싶다면? 
```java
    String[] words= ["hello","World"];
        words.stream()
        .map(word -> word.split(""))
        .distinct()
        .collect(toList());
```
- 위 코드에서는 map 이 반환한게 String<String[]> 이라 실패 


- map과 Array.stream활용
```java
    words.stream()
	.map(word -> word.split("")
        .map(Arrays::stream) <- 각 배열을 별도의 스트림으로 생성 
	.distinct()
	.collect(toList());
```
- 이렇게 해도 List<Stream<String>> 이 만들어진거니까 실패 


- flatMap 사용
```java
   words.stream()
	.map(word -> word.split("")
        .flatMap(Arrays::stream) <- 생성된 스트림을 하나의 스트림으로 평면화  
	.distinct()
	.collect(toList());
```
- flatMap은 각 배열을 스트림이 아니라 스트림의 콘텐츠로 매핑. 즉 하나의 평면화된 스트림을 반환.
- 스트림의 각 값을 다른 스트림으로 만든 다음 모든 스트림을 하나의 스트림으로 연결하는 기능을 수행


- 예시
```java
    List<Integer> numbers1 = Arrays.asList(1,2,3,4,5);
    List<Integer> numbers2 = Arrays.asList(6,7,8);
    List<int[]> pairs = numbers1.stream()
        .flatMap((Integer i) -> numbers2.stream()
            .map((Integer j) -> new int[]{i, j})
        )
        .filter(pair -> (pair[0] + pair[1]) % 3 == 0)
        .collect(toList());
    pairs.forEach(pair -> System.out.printf("(%d, %d)", pair[0], pair[1]));
```
## 5.4 검색과 매칭 

- 특정 속성이 데이터 집합에 있는지 여부를 검색하는 데이터 처리
### 5.4.1 프레디케이트가 적어도 한 요소와 일치하는지 확인 

- anyMatch: 프레디케이트가 주어진 스트림에서 적어도 한 요소와 일치하는지 확인할때 
```java
menu.stream().anyMatch(Dish::isVegetarian);
```
### 5.4.2 프레디케이트가 모든 요소와 일치하는지 검사 

- allMatch : 스트림의 모든 요소가 주어진 프레디케이트와 일치하는지
```java
 menu.stream().allMatch(d -> d.getCalories() < 1000);
```

- noneMatch : allMatch랑 반대. 주어진 프레디케이티와 일치하는 요소가 없는지 확인
```java
menu.stream().noneMatch(d -> d.getCalories() >= 1000);
```

- 쇼트서킷 기법 활용 : && , || 같이 모든 연산 처리하지 않고 결과 반환
### 5.4.3 요소 검색

- findAny : 현재스트림에서 임의의 요소를 반환
- 스트림 파이프라인은 내부적으로 단일과정으로 실행할 수 있도록 최적화함. 즉 쇼트서킷 이용해 결과 찾는 즉시 실행 종료 
```java
menu.stream().filter(Dish::isVegetarian).findAny();
```

- Optional 이란 ?
  - Optional<T> 클래스 (java.util.Optional) 는 값의 존재나 부재 여부를 표현하는 컨테이너 클래스.
  - null 은 쉽게 에러를 내니 만들었음
  - isPresent()  : 값 포함하면 true 아님 false반환
  - ifPresent(Consumer<T> block) : 있으면 주어진 블록 실행
  - T get() : 존재하면 값 반환 없으면 NoSuchElementExceoption 일으킴
  - T orElse() : 값있으면 반환 없으면 기본값 반환 
### 5.4.4 첫번째 요소 찾기

- 일부 스트림에는 논리적인 아이템 순서가 정해져 있을 수 있음. 이때 첫 요소 찾으려면 어케야?
```java
List<Integer> someNumbers = Arrays.asList(1,2,3,4,5);
  Optional<Integer> firstSquareDivisibleByThree =
      someNumbers.stream()
        .map(n -> n * n)
        .filter(n -> n%3 == 0)
        .findFirst(); //9
```
- 병렬성 때문에 findFirst , findAny 있는거. 반환순서 필요없으면 findAny사용 

## 5.5 리듀싱

- 모든 칼로리의 합, 가장 높은 칼로리 메뉴는? 같은 스트림 요소를 조합해 더 복잡함 질의 표현
- 결과가 나올때까지 스트림의 모든 요소를 반복적으로 처리해야
- 리듀싱 연산 : 모든 스트림 요소를 처리해서 값으로 도출. 종이를 계속 접는것 같아해서 폴드라고도 부름

### 5.5.1 요소의 합 

- sum 변수의 초기값 0
- 리스트의 모든 요소를 조합하는 연산 
```java
    List<Integer> numbers = Arrays.asList(3, 4, 5, 1, 2);
    int sum = numbers.stream().reduce(0, (a, b) -> a + b);
    System.out.println(sum);

    int sum2 = numbers.stream().reduce(0, Integer::sum); // 메서드 참조를 이용해 더 간결하게
    System.out.println(sum2);
```
- 초기값 없음
  - 초기값 안받도록 오버로드된 reduce : Optional 객체를 반환함. 

### 5.5.2 최댓값과 최소값 

- 초기값 
- 스트림의 두 요소를 합쳐서 하나의 값을오 만드는데 사용할 람다. 
```java
    int max = numbers.stream().reduce(0, (a, b) -> Integer.max(a, b));

    Optional<Integer> min = numbers.stream().reduce(Integer::min); // 대신 (x,y) -> x<y? x:y 사용가능
```

- reduce메서드의 장점과 병렬화 
  - reduce 사용하면 내부 반복이 추상화 되면서 내부 구현에서 병렬로 reduce 실행 가능.
  - 반복적 합계에서는 sum 변수를 공유해야 하므로 쉽게 병렬화 하기 어렵
  - 가변 누적자 패턴은 병렬화와 너무 거리가 번 기법. parallelStrem()으로 바꾸면 된다
  - 대가 : reduce에 넘겨준 람다 상태(인스턴스 변수 같은)가 바뀌면 안되고 어떤 순서로 실행되더라고 결과가 바뀌지 않는 구조여야.
  

- 스트림 연산: 상태 없음과 상태 있음 
  - map,filter 는 각 요소를 받아 0도는 결과를 출력 스트리믕로 보냄 -> 내부상태를 갖지 않는 연상
  - reduce, max, min 은 결과를 누적할 내부상태 필요. 이 내부상태의 크기는 한정되어 있음 
  - sorted , distinct 같은 연산은 스트림받아 다른 스트림 출력하는것 같지만 정렬이나 중복제거는 과거의 이력을 알고있어야함. 즉 모든 요소가 버퍼에 추가되어 있어야 함. 연산 수행에 필요한 저장소 크기는 정해져 있지 않기에 스트림이 엄청크면 문제 생실 수 있음 . 이런 연산을 내부상태를 갖는 연산이라고 함. 
