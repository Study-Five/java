## 5.1 필터링

### 5.1.1 프레디케이트로 필터링 

- filter 메서드 : 프레디케이트를 인수로 받아 일치하는 모든 요소를 포함하는 스트림을 반환. 
```java
    List<Dish> vegetarianMenu = menu.stream()
        .filter(Dish::isVegetarian)
        .collect(toList());
```

### 5.1.2 고유 요소 필터링

- distinct : 고유요소로 이루어진 스트림 반환 (hashCode, equals로 결정)
```java
    List<Integer> numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);
    numbers.stream()
        .filter(i -> i % 2 == 0)
        .distinct()
```
## 5.2 스트림 슬라이싱 

- 스트림의 요 소를 선택하거나 스킵하는 다양한 방법. 
```java
    List<Dish> specialMenu = Arrays.asList(
        new Dish("season fruit", true, 120, Dish.Type.OTHER),
        new Dish("prawns", false, 300, Dish.Type.FISH),
        new Dish("rice", true, 350, Dish.Type.OTHER),
        new Dish("chicken", false, 400, Dish.Type.MEAT),
        new Dish("french fries", true, 530, Dish.Type.OTHER));
```
### 5.2.1 프레디케이트를 이용한 슬라이싱 

- TAKEWHILE활용 
- 리스트가 이미 정렬돼있다는 사실을 이용해 320보다 크면 반복작업을 중단 -> 큰 스트림에서 효율적
```java
    List<Dish> slicedMenu1 = specialMenu.stream()
        .takeWhile(dish -> dish.getCalories() < 320)
        .collect(toList());
```

- DROPWHILE 활용 
- 320보다 큰 요소 탐색 
```java
    List<Dish> slicedMenu2 = specialMenu.stream()
        .dropWhile(dish -> dish.getCalories() < 320)
        .collect(toList());
```
- 프레디케이트가 처음으로 거짓이 되는 지점까지 발견된 요소를 버림. 거짓되는 지점에서 작업 중단 후 남은 요소 반환.

### 5.2.2 스트림 축소 

- limit(n) : 주어진 값 이하의 크기를 갖는 새로운 스트림 반환
- 정렬되지 않은 스트림에도 사용가능 -> 정렬안된 상태로 반환
```java
    List<Dish> dishesLimit3 = menu.stream()
        .filter(d -> d.getCalories() > 300)
        .limit(3)
        .collect(toList());
```
### 5.2.3 요소 건너뛰기

- skip(n) : 처음n개 요소를 제외한 스트림을 반환 
- n개 이하 스트림에 호출하면 빈 스트림 반환됨. 
```java
    List<Dish> dishesSkip2 = menu.stream()
        .filter(d -> d.getCalories() > 300)
        .skip(2)
        .collect(toList());
```

## 5.3 매핑

- 특정 객체에서 특정 데이터 선택 기능

### 5.3.1 스트림의 각 요소에 함수 적용하기 

- map : 함수를 인수로 받아 각 요소에 적용 되서 새로운 요소 매핑된 결과 반환.
```java
    List<String> dishNames = menu.stream()
        .map(Dish::getName)
        .collect(toList()); //- getName()은 String 반환하므로 Stream<String> 형식 갖음. 

	List<String> dishNames = menu.stream()
	.map(Dish::getName)
        .map(String::length) // 다른 map을 연결 가능 
	.collect(toList());

```

### 5.3.2 스트림 평면화

- 리스트에서 고유문자로 이루어진 리스트 반환하고 싶다면? 
```java
    String[] words= ["hello","World"];
        words.stream()
        .map(word -> word.split(""))
        .distinct()
        .collect(toList());
```
- 위 코드에서는 map 이 반환한게 String<String[]> 이라 실패 


- map과 Array.stream활용
```java
    words.stream()
	.map(word -> word.split("")
        .map(Arrays::stream) <- 각 배열을 별도의 스트림으로 생성 
	.distinct()
	.collect(toList());
```
- 이렇게 해도 List<Stream<String>> 이 만들어진거니까 실패 


- flatMap 사용
```java
   words.stream()
	.map(word -> word.split("")
        .flatMap(Arrays::stream) <- 생성된 스트림을 하나의 스트림으로 평면화  
	.distinct()
	.collect(toList());
```
- flatMap은 각 배열을 스트림이 아니라 스트림의 콘텐츠로 매핑. 즉 하나의 평면화된 스트림을 반환.
- 스트림의 각 값을 다른 스트림으로 만든 다음 모든 스트림을 하나의 스트림으로 연결하는 기능을 수행


- 예시
```java
    List<Integer> numbers1 = Arrays.asList(1,2,3,4,5);
    List<Integer> numbers2 = Arrays.asList(6,7,8);
    List<int[]> pairs = numbers1.stream()
        .flatMap((Integer i) -> numbers2.stream()
            .map((Integer j) -> new int[]{i, j})
        )
        .filter(pair -> (pair[0] + pair[1]) % 3 == 0)
        .collect(toList());
    pairs.forEach(pair -> System.out.printf("(%d, %d)", pair[0], pair[1]));
```
## 5.4 검색과 매칭 

- 특정 속성이 데이터 집합에 있는지 여부를 검색하는 데이터 처리
### 5.4.1 프레디케이트가 적어도 한 요소와 일치하는지 확인 

- anyMatch: 프레디케이트가 주어진 스트림에서 적어도 한 요소와 일치하는지 확인할때 
```java
menu.stream().anyMatch(Dish::isVegetarian);
```
### 5.4.2 프레디케이트가 모든 요소와 일치하는지 검사 

- allMatch : 스트림의 모든 요소가 주어진 프레디케이트와 일치하는지
```java
 menu.stream().allMatch(d -> d.getCalories() < 1000);
```

- noneMatch : allMatch랑 반대. 주어진 프레디케이티와 일치하는 요소가 없는지 확인
```java
menu.stream().noneMatch(d -> d.getCalories() >= 1000);
```

- 쇼트서킷 기법 활용 : && , || 같이 모든 연산 처리하지 않고 결과 반환
### 5.4.3 요소 검색

- findAny : 현재스트림에서 임의의 요소를 반환
- 스트림 파이프라인은 내부적으로 단일과정으로 실행할 수 있도록 최적화함. 즉 쇼트서킷 이용해 결과 찾는 즉시 실행 종료 
```java
menu.stream().filter(Dish::isVegetarian).findAny();
```

- Optional 이란 ?
  - Optional<T> 클래스 (java.util.Optional) 는 값의 존재나 부재 여부를 표현하는 컨테이너 클래스.
  - null 은 쉽게 에러를 내니 만들었음
  - isPresent()  : 값 포함하면 true 아님 false반환
  - ifPresent(Consumer<T> block) : 있으면 주어진 블록 실행
  - T get() : 존재하면 값 반환 없으면 NoSuchElementExceoption 일으킴
  - T orElse() : 값있으면 반환 없으면 기본값 반환 
### 5.4.4 첫번째 요소 찾기

- 일부 스트림에는 논리적인 아이템 순서가 정해져 있을 수 있음. 이때 첫 요소 찾으려면 어케야?
```java
List<Integer> someNumbers = Arrays.asList(1,2,3,4,5);
  Optional<Integer> firstSquareDivisibleByThree =
      someNumbers.stream()
        .map(n -> n * n)
        .filter(n -> n%3 == 0)
        .findFirst(); //9
```
- 병렬성 때문에 findFirst , findAny 있는거. 반환순서 필요없으면 findAny사용 

## 5.5 리듀싱

- 모든 칼로리의 합, 가장 높은 칼로리 메뉴는? 같은 스트림 요소를 조합해 더 복잡함 질의 표현
- 결과가 나올때까지 스트림의 모든 요소를 반복적으로 처리해야
- 리듀싱 연산 : 모든 스트림 요소를 처리해서 값으로 도출. 종이를 계속 접는것 같아해서 폴드라고도 부름

### 5.5.1 요소의 합 

- sum 변수의 초기값 0
- 리스트의 모든 요소를 조합하는 연산 
```java
    List<Integer> numbers = Arrays.asList(3, 4, 5, 1, 2);
    int sum = numbers.stream().reduce(0, (a, b) -> a + b);
    System.out.println(sum);

    int sum2 = numbers.stream().reduce(0, Integer::sum); // 메서드 참조를 이용해 더 간결하게
    System.out.println(sum2);
```
- 초기값 없음
  - 초기값 안받도록 오버로드된 reduce : Optional 객체를 반환함. 

### 5.5.2 최댓값과 최소값 

- 초기값 
- 스트림의 두 요소를 합쳐서 하나의 값을오 만드는데 사용할 람다. 
```java
    int max = numbers.stream().reduce(0, (a, b) -> Integer.max(a, b));

    Optional<Integer> min = numbers.stream().reduce(Integer::min); // 대신 (x,y) -> x<y? x:y 사용가능
```

- reduce메서드의 장점과 병렬화 
  - reduce 사용하면 내부 반복이 추상화 되면서 내부 구현에서 병렬로 reduce 실행 가능.
  - 반복적 합계에서는 sum 변수를 공유해야 하므로 쉽게 병렬화 하기 어렵
  - 가변 누적자 패턴은 병렬화와 너무 거리가 번 기법. parallelStrem()으로 바꾸면 된다
  - 대가 : reduce에 넘겨준 람다 상태(인스턴스 변수 같은)가 바뀌면 안되고 어떤 순서로 실행되더라고 결과가 바뀌지 않는 구조여야.
  

- 스트림 연산: 상태 없음과 상태 있음 
  - map,filter 는 각 요소를 받아 0도는 결과를 출력 스트리믕로 보냄 -> 내부상태를 갖지 않는 연상
  - reduce, max, min 은 결과를 누적할 내부상태 필요. 이 내부상태의 크기는 한정되어 있음 
  - sorted , distinct 같은 연산은 스트림받아 다른 스트림 출력하는것 같지만 정렬이나 중복제거는 과거의 이력을 알고있어야함. 즉 모든 요소가 버퍼에 추가되어 있어야 함. 연산 수행에 필요한 저장소 크기는 정해져 있지 않기에 스트림이 엄청크면 문제 생실 수 있음 . 이런 연산을 내부상태를 갖는 연산이라고 함.
  
## 5.7 숫자형 스트림 
```java
int calories = menu.stream()
  .map(Dish::getCalories)
  .reduce(0,Integer::sum);

int calories = menu.stream()
    .map(Dish::getCalories)
    .sum();
```

- 위 코드처럼 박싱비용 없이 sum 바로 호출 하고싶지만 안됨. map이 Stream<T>를 생성하기 때문 
- 숫자 스트림의 효율적 처리 위한 기본형 특화 스트림 제공 

### 5.7.1 기본형 특화 스트림 

- int, double,long 제공. sum,max 같은 숫자관련 리듀싱 연상 수행 메서드 제공
- 필요시 다시 객체스트림으로 복원기능 제공
- 특화 스트림은 오직 박싱 과정에서 일어나는 효율성과 관련. 스트림에추가 기능은 제공x


#### 숫자 스트림으로 매핑 
```java
int calories = menu.stream()
  .mapToInt(Dish::getCalories)
  .sum();
```
- 스트림 비었으면 기본값 0 반환. max,min,average 등 지원 

#### 객체스트림으로 복원하기 
```java
IntStream intStream = menu.stream().mapToInt(Dish::getCalories);
Stream<Integer> stream = intStream.boxed(); // 숫자 스트림을 스트림으로 변환 
```
- 특화 스트림을 일반스트림으로 변환.

#### 기본값 : OptionalInt

- 최댓값 찾을때 기본값 0은 잘못된 결과 도출 가능 
- Optional 은 Integer,String 등의 참조형식으로 파라미터화 가능 
- OptionalInt,OptionalDouble,OptionalLong 기본형 특화스트림 버전도 제공
```java
  OptionalInt maxCalories = menu.stream()
      .mapToInt(Dish::getCalories)
      .max();

int max = maxCalories.orElse(1);// 값이 없을때 기본 최대값 명시적 지정 가능 
```
---

### 5.7.2 숫자 범위 

- range , rangeClosed : 첫 인수 시작, 두번째 인수로 종료값. range는 시작종료값 결화 포함x ,rangeClosed는 포함
- 1~100 숫자 만들기
```java
    IntStream evenNumbers = IntStream.rangeClosed(1, 100)
        .filter(n -> n % 2 == 0);
    System.out.println(evenNumbers.count());
```

### 5.7.3 숫자 스트림 활용 : 피타고라스 수 

#### 피타고라스 수 
- a * a + b * b = c * c 만족하는 세개의 정수 . 3,4,5

#### 세 수 표현하기

- new Int[] {3,4,5} 배열로 표현

#### 좋은 필터링 조합 

- a * a + b * b 의 제곱근이 정수인지 확인 : Math.sqrt(a * a + b * b) %1 == 0;
- x가 부동소숫점이라면 x % 1.0 : 소숫점 이하 부분 얻음. 
- filter(b -> Math.sqrt(a * a + b * b) % 1 == 0) 로 활용 가능

#### 집합생성 

- 좋은 조합인 a,b를 선택 후 map을 이용해 각 요소를 피타고라스 수로 변환 
```java
stream.filter(b -> Math.sqrt(a * a + b * b) % 1 == 0)
      .map(b -> new int[] { a, b, (int) Math.sqrt(a * a + b * b) }));
```

#### b값 생성 

- Stream.rangeClosed로 주어진 범위 수 b 생성 
- filter 후 boxed 이용해 Stream<Integer> 로 복원. (map 은 스트림 요소를 int배열로 변환하기 때문)
```java
IntStream.rangeClosed(1, 100)
        .filter(b -> Math.sqrt(a * a + b * b) % 1 == 0)
        .boxed()
        .map(b -> new int[] { a, b, (int) Math.sqrt(a * a + b * b) }));


IntStream.rangeClosed(1, 100)
        .filter(b -> Math.sqrt(a * a + b * b) % 1 == 0)
        .mapToObj(b -> new int[] { a, b, (int) Math.sqrt(a * a + b * b) }));
// 개체갑 ㅅ스트림 반환하는 Intstream.mapToObj 이용해 코드 재구현 
```

#### a값 생성

- b와 비슷한 방법으로 a값 생성하는 코드 추가 
```java
    Stream<int[]> pythagoreanTriples = IntStream.rangeClosed(1, 100).boxed()
        .flatMap(a -> IntStream.rangeClosed(a, 100)
            .filter(b -> Math.sqrt(a * a + b * b) % 1 == 0).
            .mapToObj(b -> new int[] { a, b, (int) Math.sqrt(a * a + b * b) }));
```
- flatMap : a에 사용한 1~100 숫자 생성 후 a를 이요해 세수의 스트림 만듬. 스트림a에 값 매핑하면 스트림의 스트림이 만들어 질꺼니 생성된 각각의 스트림을 하나의 평준화된 스트림으로 만들어줌. 
- b의 범위가 a~100 으로 바뀐것 : 1부터 시작하면중복된 세 수 (3,4,5)(4,3,5) 가능하기에

#### 코드 실행

- limit 이용해 얼마 많은 세수 스트림 생성할지 결정 

#### 개선할 점?

- 위 코드는 제곱근을 두번 계산함. (a * a, b * b, a * a+ b* b) 충족하는 세 수 만든후 조건 맞는 결과만 필터링
```java
    Stream<int[]> pythagoreanTriples2 = IntStream.rangeClosed(1, 100).boxed()
        .flatMap(a -> IntStream.rangeClosed(a, 100)
            .mapToObj(b -> new double[]{a, b, Math.sqrt(a * a + b * b)})
            .filter(t -> t[2] % 1 == 0))
        .map(array -> Arrays.stream(array).mapToInt(a -> (int) a).toArray());
```

## 5.8 스트림 만들기 

### 5.8.1 값으로 스트림 만들기 
```java
    // Stream.of
    Stream<String> stream = Stream.of("Java 8", "Lambdas", "In", "Action");
    stream.map(String::toUpperCase).forEach(System.out::println);

    // Stream.empty
    Stream<String> emptyStream = Stream.empty();
```

### 5.8.2 null 이 될 수 있는 객체로 스트림 만들기 

- 9부터 추가. ofNullable
```java
Stream<String> homeValueStream 
= Stream.ofNullable(System.getProperty("home"));

Stream<String> values 
= Stream.of("config","home","user")
.flatMap(key -> Stream.ofNullable(System.getProperty(key))));
```

### 5.8.3 배열로 스트림 만들기 
```java
 int[] numbers = {1,2,3,4,5};
int sum = Arrays.stream(numbers).sum();
```

### 5.8.4 파일로 스트림 만들기 
```java
    long uniqueWords = Files.lines(Paths.get("lambdasinaction/chap5/data.txt"), Charset.defaultCharset())
        .flatMap(line -> Arrays.stream(line.split(" ")))
        .distinct()
        .count();
```

### 5.8.5 함수로 무한 스트림 만들기 

- Stream.iterate , Stream.generate로 크기가 고정되지 않은 무한 스트림 생성 가능. 
- 무제한으로 값 계산할 수는 있지만 무한히 출력하지 않도록 limit(n) 연결해 사용 

#### iterate 메서드 
```java
    Stream.iterate(0, n -> n + 2)
        .limit(10)
        .forEach(System.out::println);
```
- 초깃값과 람다를 인수로 받아 새로운 값 끊임없이 생산 가능. 
- 언바우드 스트림 : 요청시 마다 값 생성. 끊이 없으므로 무한 스트림 만듬.
- 피보나치 예제
```java
    Stream.iterate(new int[] { 0, 1 }, t -> new int[] { t[1], t[0] + t[1] })
        .limit(10)
        .map(t -> t[0])
        .forEach(System.out::println);
```

- 자바9 iterate메서드는 프레디케이트 지원. 생성 중단 가능. 
- 두번째 인수로 프레디케이를 받아 언제까지 수행할지 기준으로
```java
IntStream.iterage(0, n -> n<100 , n -> n+4)
    .forEach(System.out::println);
```

#### generate메서드 
- iterate와 달리 생산된 값을 연속적으로 계산 않고 Supplier<T> 를 인수로 받아 새로운 값 생산.
```java
    Stream.generate(Math::random)
        .limit(10)
        .forEach(System.out::println);
```
- IntStream 은 IntSupplier 인수로 받아 생성 
```java
    // Stream.generate을 이용한 요소 1을 갖는 스트림
    IntStream.generate(() -> 1)
        .limit(5)
        .forEach(System.out::println);

    IntStream.generate(new IntSupplier() {
      @Override
      public int getAsInt() {
        return 2;
      }
    }).limit(5).forEach(System.out::println);
```

- intSupplier 인스턴스 만들어 하면 기존 피보나치 요소와 두 인스턴스 변수 에 어떤 요소가 들어있는지 추적하므로 가변 상태 객체
- getAsInt 호출하면 객체 상태가 바뀌며 새 값 생성. 
- iterate 사용시에는 새 값 사용하면서도 기존 상태 바꾸지 않는 순수한 분변 상태 유지 
- 병렬 처리시 불변상태기법 고수해야. -> 7장