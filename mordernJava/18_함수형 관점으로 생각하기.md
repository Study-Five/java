## 18.1 시스템 구형과 유지보수

- 쉽게 유지 보수할 수 있는 프로그램이란 시스템의 구조를 이해하기 쉽게 클래스 계층으로 반영하는 프로그램이다. 프로그램 구조는 아래의 2가지 도구로 평가할 수 있다.
  -  결합성: 시스템의 각 부분의 상호 의존성을 가리키는 것
  - 응집성: 시스템의 다양한 부분이 서로 어떤 관계를 갖는지 가리키는 것
- 그러나 이런 구조여도 유지보수 중 예상하지 못한 변수값에 의한 문제가 많이 발생한다. 이 문제는 함수형 프로그래밍이 보장해주는 부작용 없음과 불변성이 해결해 줄 수 있다.

### 18.1.1 공유된 가변 데이터 

- 일반적으로 변수가 예상하지 못한 값을 갖는 이유는 우리가 유지보수하는 시스템의 여러 메서드에서 공유된 값을 읽고 갱신하기 때문이다.
- 자신을 포함하는 클래스의 상태 그리고 다른 객체의 상태를 바꾸지 않으며 return문을 통해서만 자신의 결과를 반환하는 메서드를 순수 메서드 또는 부작용 없는 메서드라고 부른다.
- 부작용
  - 자료구조를 고치거나 필드에 값을 할당
  - 예외 발생
  - 파일에 쓰기 등의 I/O 동작 수행
- 불변 객채를 이용해서 부작용을 없애는 방법도 존재.
- 불변객체는 인스턴스화 한 다음에는 상태를 바꿀수 없기 때문에 스레드 안정성을 보장한다.

### 18.1.2 선언형 프로그래밍

- 시스템을 구현하는 두 방식
  - 어떻게(how) 수행할 것인지 집중하는 방법 - 명령형 프로그래밍(절차지향, 객체지향)
  - 무엇을(what) 수행할 것인지 집중하는 방법 - 선언형 프로그래밍(함수형 프로그래밍)
  
### 18.1.3 왜 함수형 프로그래밍인가?

- 함수형 프로그래밍은  선언형 프로그래밍을 따르는 대표적인 방식.
- 부작용 없는 계산을 지향
- 함수형 프로그래밍을 이용하면 부작용이 없는 복잡하고 어려운 기능을 수행하는 프로그램을 구현 가능

## 18.2 함수형 프로그래밍이란 무엇인가?

- 함수형 프로그래밍의 간단한 정의 : 함수를 활용하는 프로그래밍 기법
-  '함수 그리고 if-then-else 등의 수학적 표현만 사용'라는 방식을 순수 함수형 프로그래밍이라고 하며 '시스템의 다른 부분에 영향을 미치지 않는다면 내부적으로는 함수형이 아닌 기능도 사용'하는 방식을 함수형 프로그래밍이라 한다.

### 18.2.1 함수형 자바

- 실질적으로 자바에서는 완벽한 순수 함수형 프로그래밍을 구현하기는 어렵 ->순수 함수형이 아니라 함수형 프로그램을 구현.
- 실제로는 부작용이 있지만 아무도 이를 보지 못하게 함으로 함수형을 달성 가능 .
- 함수나 메서드는 지역변수만을 변경해야 함수형. 또한 참조하는 객체가 있다면 반드시 불변객체이어야 한다.
- 즉 객체의 모든 필드가 final이어야 하고 모든 참조 필드는 불변 객체를 직접 참조해야 한다.
- 함수형이라면 함수나 메서드가 어떤 예외도 일으키지 않아야 한다. -> 예외발생시 return 불가 -> 함수형 수학적 활용에 걸림돌
- 모든 연산은 하나의 결과를 도출하게 되는데 이때 에러가 발생하면 결과를 도출 불가 -> Optional 을 사용
- 모든 상황에 Optional을 사용하는것이 아니라 다른 컴포넌트에 영향을 미치지 않도록 구현하면 된다.
- 비 함수형 동작을 감출 수 있는 상황에서만 부족용을 포함하는 라이브러리 함수를 사용해야.(ex컬렉션을 미리 복사한다던가 발생할 수 있는 예제를 적절하게 내부에서 처리 )

###18.2.2 참조 투명성

- 함수에 같은 인수를 넣었을 때 항상 같은 결과를 반환한다면 이것을 참조적으로 투명한 함수
```java
"raoul".replace('r', 'R'); // 항상 같은 결과가 나오므로 String.replace는 참조적으로 투명(원본을 변경하지 않고 새로운 객체를 생성한다)

Random random = new Random();
Random.nextInt() // 호출시 매번 다른 값이 나오므로 참조 투명 x

Scanner scanner = new Scanner(System.in);
scanner.nextLine() // 호출시 매번 다른 결과가 나오므로 참조 투명 x
```
- 참조 투명성은 프로그램 이해에 큰 도움을 줌
- 비싸거나 오랜 시간이 걸리는 연산을 기억화 또는 캐싱을 통해 다시 계산하지 않고 저장하는 최적화 기능도 제공

### 18.2.3 객체지향 프로그래밍과 함수형 프로그래밍

- 자바 8은 함수형 프로그래밍을 익스트림 객체지향 프로그래밍(모든 것을 객체로 간주하고 프로그램이 객체의 필드를 갱신하고, 메서드를 호출하고, 관련 객체를 갱신하는 방식)의 일종으로 간주.
- 하드웨어의 변경 + 질의와 비슷한 방식으로 데이터를 조작하고자하는 프로그래머의 기대치 -> 함수형으로 바뀌고 있는 추세
- 자바 프로그래머는 익스트림 객제지향 프로그래밍과 함수형 프로그래밍(참조적 투명성을 중시하는, 변화를 허용하지 않는)을 혼합해서 사용한다.

### 18.2.4 함수형 실전 연습
```java
public static void main(String[] args) {
    List<List<Integer>> subs = subsets(Arrays.asList(1, 4, 9));
    subs.forEach(System.out::println);
}

// 인수로 받는 list가 변경 되지 않으므로 함수형이라고 볼 수 있다.
public static List<List<Integer>> subsets(List<Integer> list) {
    if (list.isEmpty()) {
        List<List<Integer>> answer = new ArrayList<>();
        answer.add(Collections.emptyList());
        return answer;
    }
    Integer first = list.get(0);
    List<Integer> rest = list.subList(1, list.size());
    List<List<Integer>> subAnswer = subsets(rest);
    List<List<Integer>> subAnswer2 = insertAll(first, subAnswer);
    return concat(subAnswer, subAnswer2);
}

public static List<List<Integer>> insertAll(Integer first, List<List<Integer>> lists) {
    List<List<Integer>> result = new ArrayList<>();
    for (List<Integer> list : lists) {
        List<Integer> copyList = new ArrayList<>(); // 받아온 리스트를 복사해서 사용. Integer가 불변이 아니라면 각 요소도 모두 복사해야함.
        copyList.add(first);
        copyList.addAll(list);
        result.add(copyList);
    }
    return result;
}

// 순수 함수. 내부적으로 리스트 r에 요소를 추가하는 변화가 생기지만, 반환 결과는 인수에 의해서만 이루어지며, 인수의 상태가 변경되지도 않는다.
static List<List<Integer>> concat(List<List<Integer>> a, List<List<Integer>> b) {
    List<List<Integer>> r = new ArrayList<>(a);
    r.addAll(b);
    return r;
}

----------------------------------------------------------------------------------

// a의 값이 다시 참조된다면 상태의 변화가 생길 수 있다. 
static List<List<Integer>> concat(List<List<Integer>> a, List<List<Integer>> b) {
    a.addAll(b);
    return a;
}

```
## 18.3 재귀와 반복

- 순수 함수형 프로그래밍 언어에서는 while과 for 같은 반복문을 포함하지X -> 반복문의 변화가 코드에 반영 가능
- 함수형 스타일에서는 지역 변수는 자유롭게 갱신할 수 있다.(변화를 알아차리지만 못한다면 아무 상관이 없다.)

```java
// 호출자는 변화를 알 수 없으므로 상관없다.
Iterator<Apple> it = apples.iterator(); // iterator()는 새로운 Itr 객체를 반환
while (it.hasNext()) {
    Apple apple = it.next(); 
    // ...
}
// 공유되는 stats의 상태가 변화되므로 문제가 발생할 수 있다.
public void searchForGold(List<String> list, Stats stats) {
    for (String string : list) {
        if ("gold".equals(string)) {
            stats.incrementFor("gold"); // stats가 다른 부분과 공유되고 있는 상태인데 반복문 안에서 상태가 변화되고 있음
        }
    }
}
```
- 반복문을 사용할 경우, 함수형 프로그래밍이 깨질 수 있다. 이럴때 재귀를 사용하면 변화가 일어나지 않는다.
```java
// 반복 방식 팩토리얼
public int factorialIterative(int n) {
    int r = 1;
    for (int i = 1; i <= n; i++) { 
        r *= i; 
    }
    return r;
}
// 재귀 방식 팩토리얼
public long factorialRecursive(long n) {
    if (n == 1) {
        return 1;
    }
    return n * factorialRecursive(n - 1); // 최종 연산이 n * 재귀 호출 결과값
}
// 스트림을 사용한 팩토리얼
public long factorialStreams(long n) {
    return LongStream.rangeClosed(1, n)
            .reduce(1, (a, b) -> a * b);
}
```
- 무조건 반복보다 재귀가 좋다고는 할 수 없다.
  - 재귀코드가 자원을 더 많이 사용한다. 재귀는 호출될 때마다 호출 스택에 호출시 생성되는 정보를 저장할 스택 프레임이 만들어진다. 즉, 입력값에 따라 만들어지는 스택 프레임이 늘어나므로 메모리 사용량이 증가한다.
  
- 꼬리 호출 최적화
```java
// 꼬리 재귀 팩토리얼
public long factorialTailRecursive(long n) {
    return factorialHelper(1, n);
}

private long factorialHelper(long acc, long n) {
    if (n == 1) {
        return acc;
    }
    return factorialHelper(acc * n, n - 1); // 최종 연산이 재귀호출
}
```
- 일반 재귀는 중간 결과를 각각의 스택 프레임으로 저장해야하지만, 꼬리 재귀는 컴파일러가 하나의 스택 프레임을 재활용
- 자바는 최적화 제공 않지만 최신JVM언어(스칼라, 그루비) 는 제공 
- 결론적으로는 자바에서는 반복을 스트림으로 대체해서 변화를 피할 수 있다. 또한 반복을 재귀로 바꿔 부작용이 없는 알고리즘을 만들 수 있다.