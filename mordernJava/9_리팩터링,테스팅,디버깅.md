## 9.1 가독성과 유연성을 개선하는 리팩터링 

- 람다표현식, 메서드참조, 동작파라미터화를 사용해 가독성 좋고 유연한 코드로  리팩터링

### 9.1.1 코드 가독성 개선 

- 코드 가독성 : 다른 사람이 쉽게 이해하고 유지보수 할 수 있는 코드. 코드의 문서화, 표준 코딩 규칙 준수 

### 9.1.2 익명클래스를 람다 표현식으로 리팩터링 하기 

- 람다 표현식 이용해 간결, 가독성 좋은 코드 구현 
1. 익명 클래스에서 this, super는 람다에서 다른의미 갖음. 익명 클래스에서 thos는 익명 클래스 자신/ 람다에선 람다를 감싸는 클래스.
2. 익명클래스 감싸고 있는 클래스의 변수 가릴 수 있다 (섀도변수) but 람다는 변수를 가릴 수 없다. 
```java
	int a = 10;
	Runnable r1 = () -> {
		int a = 2; // 컴파일 에러 
		System.out.println(a);
	};

	Runnable r2 = new Runnable() {
		@Override
		public void run() {
			int a = 2; // 잘 동작 
			System.out.println(a);
		}
	};
```
3. 익명클래스 -> 람다 시 콘텍스트 오버로딩에 따른 모호함 초래 가능. 익명은 인스턴스화 할때 명시적 형식이 정해지는 반면 람다는 콘텍스트에 따라 달라짐  
```java
	interface Task {
	    public void execute();
        }

	public static void doSomething(Runnable r) {
		r.run();
	}

	public static void doSomething(Task a) {
		a.execute();
	}
	doSomething(new Task() {
		@Override
		public void execute() {
			System.out.println("danger");
		}
	});
	doSomething((Task)() -> System.out.println("dager")); // 명시적 형변환을 이용해 모호함 제거 
```
### 9.1.3 람다 표현식을 메서드 참조로 리팩터링 하기 

- 람다 대신 메서드 참조 이용해 가독성 높히고 메서드 명으로 코드 의도 명확하게 
```java
  private static Map<CaloricLevel, List<Dish>> groupDishesByCaloricLevel() {
    return menu.stream().collect(
        groupingBy(dish -> {
          if (dish.getCalories() <= 400) {
            return CaloricLevel.DIET;
          }
          else if (dish.getCalories() <= 700) {
            return CaloricLevel.NORMAL;
          }
          else {
            return CaloricLevel.FAT;
          }
        })
    );
  }

	Map<CaloricLevel, List<Dish>> groupDishesByCaloricLevel() =
    menu.stream().collect(groupingBy(Dish::getCaloricLevel));
```
- comparing, maxBy 같은 정적 헬퍼 메서드 활용도 좋음. 
- 내장 컬렉터 이용해 코드 자체로 문제를 명확히 
```java
menu.stream().collect(groupingBy(Dish::getType,	summingInt(Dish::getCalories)));
```
### 9.1.4 명령형 데이터 처리를 스트림으로 리팩터링 하기 

- 이론적으론 반복자 이용한 컬렉션 처리를 모두 스트림api로 바꿔야. 
- 스트림은 쇼트서킷과 게으름 이란 강력한 최적화, 멀티코어 아키텍처 활용 할 수 있음 
```java
menu.parallelStream().filter(d -> d.getCalories() > 300).map(Dish::getName).collect(toList());
```
- 명령형 코드의 break, continue, return 등 제어 흐름문 모두 분석해 같은 기능 수행 스트림 연산 변환 쉽지 않음. -> 몇가지 도구 있음 
- 
### 9.1.5 코드 유연성 개선

- 람다 표현식 이용해 동작파라미터화 쉽게 구현. 다양한 동작 표현. 변화하는 요구사항에 대응하는 코드 생산

#### 함수형 인터페이스 적용 

- 함수형 인터페이스를 코드에 추가. 
#### 조건부 연기 실행 

- 실제 작업을 처리하는 코드 내부에 제어 흐름문이 복잡하게 얽힌 코드 (보안검사, 로깅 등 )
```java
if (logger.isLoggable(Log.FINER)){
	logger.finer("problem : "+generateDiagonstic());
    }
    
logger.log(Level.FINER,"problem : "+generateDiagonstic()); // 불필요 if문 제거. 상태노출x

public void log(Level level, Supplier<String> msgSupplier) //오버로드된 log메서드 
```
- 문제
  - logger상태가 isLoggable메서드 통해 클라이언트 코드로 노출
  - 로깅시마다 logger상태 확인

#### 실행 어라운드 

- 매번 같은 준비, 종료 과정 반복 수행 코드를 람다로 변환 -> 재사용성 , 코드중복 감소

## 9.2 람다로 객체지향 디자인 패턴 리팩터링 하기

- 디자인패턴 : 다양한 패턴을 유형별로 정리한것
- 공통적인 소프트웨어 문제 설계시 재사용 가능한 검증된 청사진 제공. 
- 람다를 이용해 디자인패턴으로 해결하던 문제를 쉽고 간단히 해결 

###9.2.1 전략

- 전략패턴 : 한 유혀으이 알고리즘을 보유한 상태에서 런타임에 적절한 알고리즘 선택하는 기법 
- 다양한 기준을 갖는 입력값 검정, 다양한 파싱방법 사용, 입력형식 설정 등 다양한 시나리오에 활용. 
```java
public class StrategyMain {

  public static void main(String[] args) {
    // old school
    Validator v1 = new Validator(new IsNumeric());
    System.out.println(v1.validate("aaaa"));
    Validator v2 = new Validator(new IsAllLowerCase());
    System.out.println(v2.validate("bbbb"));

    // with lambdas
    Validator v3 = new Validator((String s) -> s.matches("\\d+"));
    System.out.println(v3.validate("aaaa"));
    Validator v4 = new Validator((String s) -> s.matches("[a-z]+"));
    System.out.println(v4.validate("bbbb"));
  }

  interface ValidationStrategy {
    boolean execute(String s);
  }

  static private class IsAllLowerCase implements ValidationStrategy {

    @Override
    public boolean execute(String s) {
      return s.matches("[a-z]+");
    }
  }

  static private class IsNumeric implements ValidationStrategy {

    @Override
    public boolean execute(String s) {
      return s.matches("\\d+");
    }
  }

  static private class Validator {

    private final ValidationStrategy strategy;

    public Validator(ValidationStrategy v) {
      strategy = v;
    }

    public boolean validate(String s) {
      return strategy.execute(s);
    }
  }
}
```
- ValidationStrategy 는 함수형 이터페이스. Predicate<String> 같은 함수 디스크립터 갖음. 
- 새 클래스 구현 없이 간결한 코드. 코드조각 캡슐화해 전략 패턴 대신함. 

### 9.2.2 템플릿 메서드 

- 알고리즘의 개요를 제시한 후 알고리즘의 일부 고칠 수 있는 유연함 제공해야할때 
```java
abstract class OnlineBanking {
  public void processCustomer(int id) {
    Customer c = Database.getCustomerWithId(id);
    makeCustomerHappy(c);
  }
  abstract void makeCustomerHappy(Customer c);
  // 더미 Customer 클래스
  static private class Customer {}
  // 더미 Database 클래스
  static private class Database {
    static Customer getCustomerWithId(int id) {
      return new Customer();
    }
  }
}

public class OnlineBankingLambda {
	public static void main(String[] args) {
		new OnlineBankingLambda().processCustomer(1337, (Customer c) -> System.out.println("Hello!"));
	}
	public void processCustomer(int id, Consumer<Customer> makeCustomerHappy) { //두번째인수로 루가 
		Customer c = Database.getCustomerWithId(id);
		makeCustomerHappy.accept(c);
	}
	// 더미 Customer 클래스
	static private class Customer {}
	// 더미 Database 클래스
	static private class Database {
		static Customer getCustomerWithId(int id) {
			return new Customer();
		}
	}
}
```
- OnlineBanking 상속 받지 않고 직접 람다 전달해 동작 추가 가능. 

### 9.2.2 옵저버

- 어떤 이벤트 발생시 한 객체(주제) 가 다른 객치리스트(옵저버) 에 자동으로 알림을 보내야 하는 상황에서 사용. 
- GUI애플리케이션 
- 옵저버가 상태를 가지고 여러 메서드를 정의하는 등 복잡하면 람다보단 기존 구현 고수가 나을수도. 
```java
public class ObserverMain {

  public static void main(String[] args) {
    Feed f = new Feed();
    f.registerObserver(new NYTimes());
    f.registerObserver(new Guardian());
    f.registerObserver(new LeMonde());
    f.notifyObservers("The queen said her favourite book is Java 8 & 9 in Action!");

    Feed feedLambda = new Feed();

    feedLambda.registerObserver((String tweet) -> {
      if (tweet != null && tweet.contains("money")) {
        System.out.println("Breaking news in NY! " + tweet);
      }
    });
    feedLambda.registerObserver((String tweet) -> {
      if (tweet != null && tweet.contains("queen")) {
        System.out.println("Yet another news in London... " + tweet);
      }
    });

    feedLambda.notifyObservers("Money money money, give me money!");
  }

  interface Observer {
    void inform(String tweet);
  }

  interface Subject {
    void registerObserver(Observer o);
    void notifyObservers(String tweet);
  }

  static private class NYTimes implements Observer {
    @Override
    public void inform(String tweet) {
      if (tweet != null && tweet.contains("money")) {
        System.out.println("Breaking news in NY!" + tweet);
      }
    }
  }

  static private class Guardian implements Observer {
    @Override
    public void inform(String tweet) {
      if (tweet != null && tweet.contains("queen")) {
        System.out.println("Yet another news in London... " + tweet);
      }
    }
  }

  static private class LeMonde implements Observer {
    @Override
    public void inform(String tweet) {
      if (tweet != null && tweet.contains("wine")) {
        System.out.println("Today cheese, wine and news! " + tweet);
      }
    }
  }

  static private class Feed implements Subject {
    private final List<Observer> observers = new ArrayList<>();
    @Override
    public void registerObserver(Observer o) {
      observers.add(o);
    }
    @Override
    public void notifyObservers(String tweet) {
      observers.forEach(o -> o.inform(tweet));
    }
  }
}
```
### 9.2.4 의무체인 

- 작업처리 객체의 체인을 만들때 사용. 한 객체가 어떤 작업을 처리한 후 다른 객체로 결과 전달, 다른 객체도 잡업후 전달 식 
- 일반적으로 정보유지 필드 포함하는 작업처리추상클래스로 구성. 
```java
public class ChainOfResponsibilityMain {

  public static void main(String[] args) {
    ProcessingObject<String> p1 = new HeaderTextProcessing();
    ProcessingObject<String> p2 = new SpellCheckerProcessing();
    p1.setSuccessor(p2); // 작업처리객체 연결 
    String result1 = p1.handle("Aren't labdas really sexy?!!");
    System.out.println(result1);

    UnaryOperator<String> headerProcessing = (String text) -> "From Raoul, Mario and Alan: " + text; //1번째처리
    UnaryOperator<String> spellCheckerProcessing = (String text) -> text.replaceAll("labda", "lambda"); //2번쨰처리
    Function<String, String> pipeline = headerProcessing.andThen(spellCheckerProcessing); //동작체인으로 두 함수 조합
    String result2 = pipeline.apply("Aren't labdas really sexy?!!");
    System.out.println(result2);
  }

  private static abstract class ProcessingObject<T> {
    protected ProcessingObject<T> successor;
    public void setSuccessor(ProcessingObject<T> successor) {
      this.successor = successor;
    }
    public T handle(T input) {
      T r = handleWork(input);
      if (successor != null) {
        return successor.handle(r);
      }
      return r;
    }
    abstract protected T handleWork(T input);
  }

  private static class HeaderTextProcessing extends ProcessingObject<String> {
    @Override
    public String handleWork(String text) {
      return "From Raoul, Mario and Alan: " + text;
    }
  }

  private static class SpellCheckerProcessing extends ProcessingObject<String> {
    @Override
    public String handleWork(String text) {
      return text.replaceAll("labda", "lambda");
    }
  }
}
```
### 9.2.5 팩토리

- 인스턴스화 로직을 클라이언트에 노풀하지 않고 객체를 만들때 사용. 
- 생성자와 설정을 외부로 노출하지 않아 클라이어트가 생산 불가
```java
public class FactoryMain {

  public static void main(String[] args) {
    Product p1 = ProductFactory.createProduct("loan");
    System.out.printf("p1: %s%n", p1.getClass().getSimpleName());

    Supplier<Product> loanSupplier = Loan::new;
    Product p2 = loanSupplier.get();
    System.out.printf("p2: %s%n", p2.getClass().getSimpleName());

    Product p3 = ProductFactory.createProductLambda("loan");
    System.out.printf("p3: %s%n", p3.getClass().getSimpleName());
  }

  static private class ProductFactory {

    public static Product createProduct(String name) {
      switch (name) {
        case "loan":
          return new Loan();
        case "stock":
          return new Stock();
        case "bond":
          return new Bond();
        default:
          throw new RuntimeException("No such product " + name);
      }
    }

    public static Product createProductLambda(String name) {
      Supplier<Product> p = map.get(name);
      if (p != null) {
        return p.get();
      }
      throw new RuntimeException("No such product " + name);
    }
  }

  static private interface Product {}
  static private class Loan implements Product {}
  static private class Stock implements Product {}
  static private class Bond implements Product {}

  final static private Map<String, Supplier<Product>> map = new HashMap<>(); //map이용해 다양한 상품 인스턴스화 
  static {
    map.put("loan", Loan::new);
    map.put("stock", Stock::new);
    map.put("bond", Bond::new);
  }
}
```
- 생성자도 메서드 참조로 접근해 객체 생성. 
- 생성자로 여러 인수 전달시 적용 어렵 -> Supplier함수형 인터페이스로 해결 
```java
public interface TriFunction<T,U,V,R> {
	R apply(T t,U u, V v);
}
```
## 9.3 람다 테스팅 

- 단위테스트 
### 9.3.1 보이는 람다 표현식의 동작 테스팅

- 람다는 익명이므로 테스트 코드 이름을 호출 불가.-> 필드에 저장해서 재사용 
- 람다표현식은 함수형 인터페이스 인스턴스 생성. -> 생성된 인스턴스 동작으로 람다 표현식 테스드. 

### 9.3.2 람다를 사용하는 메서드이 동작에 집중하라 

- 정해진 동작을 다른 메서드에서 사용할 수 있도록 하나의 조각으로 캡슐화. -> 세부구현을 포함하는 람다 공개x
- equals 적절히 구현해야 

### 9.3.3 복잡한 람다를 개별 메서드로 분할하기 

- 여러 로직 포함하는 복잡한 람다 -> 람다를 메서드 참조로 바꿔 일반메서드처럼 테스트 

### 9.3.4 고차원 함수 테스팅 

- 함수를 인수로 받거나 다른 함수 반환 메서드(고차원 함수) -> 메서드가 람다를 인수로 받으면 동작 테스트 가능.  

## 9.4 디버깅 

- 스택 트레이스/ 로깅 

### 9.4.1 스택 트레이스 확인 

- 프로그램 멈췄을때 어떻게 멈추게 됐는지 프레임별로 보여주는 스택 트레이스 -> 메서드 호출 리스트 통해 문제 발생 이해 

#### 람다와 스택 트레이스 

- 람다는 이름이 없기에 좀 복잡한 스택 트레이스 생성됨
- 미래의 자바 컴파일러 화이팅 

### 9.4.2 정보 로깅

- peek : 자신이 확인한 요소를 파이프라인 다음 연산으로 그대로 전달 
```java
    List<Integer> result = Stream.of(2, 3, 4, 5)
        .peek(x -> System.out.println("taking from stream: " + x))
        .map(x -> x + 17)
        .peek(x -> System.out.println("after map: " + x))
        .filter(x -> x % 2 == 0)
        .peek(x -> System.out.println("after filter: " + x))
        .limit(3)
        .peek(x -> System.out.println("after limit: " + x))
        .collect(toList());
```
