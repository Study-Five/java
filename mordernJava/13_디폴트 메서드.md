- 전통적 자바에서 인터페이스 구현하는 클래스는 모든 메서드 구현하거나 슈퍼클래스 구현 상속받아야.
- 인터페이스 수정 필요시 모든 상속클래스 구현 고쳐져야하는 문제. 
- 자바 8부터는
  - 인터페이스 내부에 정적메서드
  - 인터페이스 기본 구현 제공하는 티폴트 메서드  
```java
  default void sort(Comparator<? super E> c){ //반환형식 앞에 default
    Collections.sort(this,c);
  }
```
- 자바api의 호환성 유지하며 라이브러리 변경 가능. 

## 13.1 변화하는 API

- 자바 그리기 라이브러리 설계 예시 
- 추가적인 요구사항으로 setRelativeSize()가 인터페이스에 추가되면 이를 구현하지 않는 Ellipse 호출 시 문제
- 예전 버전과 새 버전 직접 관리 방법의 문제 
  - 라이브러리 관리 복잡
  - 두 라이브러리 모두 사용 -> 로딩 클래스 파일 많아지면 메모리 사용, 로딩시간에 문제 
  
#### 바이너리 호환성, 소스 호환성, 동작 호환성
 
- 바이너리 호환성 : 수정 이후 에어없이 기존 바이너리가 실행 될 수 있는 상황. ex) 인터페이스 새 메서드 추가시 호출 전엔 문제 없음
- 소스 호환성 : 수정후에도 기존 프로그램을 성공적으로 재컴파일 가능
- 동작 호환성 : 수정 후 같은 입력값이 주어지면 프로그램이 같은 동작을 실행한다. 

## 13.2 디폴트 메서드란 무엇인가 ?

- 인터페이스 상속받는 클래스에서 구현 않은 메서드는 인터페이스 자체에서 기본으로 적용 
- default키워드로 시작해 메서드 바디를 포함. 
- 자바8api 에서 디폴트 메서드 다수 활용됨. Predicate.and , Function.andThen 등 

#### 추상클래스와 자바8의 인터페이스 

- 클래스는 하나의 추상 클래스만 상속 가능. 여러 인터페이스 구현 가능 
- 추상클래스는 인스턴스변수(필드)로 공통 상태 가질 수 있음. 인터페이스는 불가.

## 13.3 디폴트 메서드 활용 패턴

### 13.3.1 선택형 메서드 

- 인터페이스 구현하는 클래스에서 메서드 내용 빈 상황 -> 디폴트 메서드로 기본 구현 제공 ex)Iterator.remove()

### 13.3.2 동작 다중 상속

- 다중상속을 이용해 기존 코드 재사용.

#### 다중상속 형식

- ArrayList 한 클ㄹ래스 상속받고, 여섯개 인터페이스 구현함(서브형식)
- 인터페이스가 구현을 포함 가능하니 여러 인터페이스에서 동작을 상속받을 수 있음.

#### 기능이 중복되지 않는 최소의 인터페이스 

- 템플릿 디자인 패턴과 비슷. Rotatable, Movable, Resizable 각 기능별 인터페이스 분리해 다양한 특성을 정의 

#### 인터페이스 조합 

- 인터페이스 조합해 게임에 필요한 다양한 클래스 구현. 

#### 올지 못한 상속 

- 하나의 메서드 위해 100개 메서드,필드 있는 클래스 상속은 비효율적
- 델리케이션 : 멤버변수를 이용해 클래스에서 필요한 메서드를 직접 호출하는 메서드 작성. final메서드

## 13.4 해석 규칙 

- 같은 시그니처를 갖는 디폴드 메서드 상속. 컴파일러가 어떻게 충돌을 해결할까?

### 13.4.1 알아야할 세가지 규칙

- 클래스가 항상 이긴다. 클래스나 슈퍼클래스에서 정의한 메서드가 디폴트 메서드보다 우선권을 갖는다.
- 1번 규칙 이외의 상황에서는 서브 인터페이스가 이긴다. 상속 관계를 갖는 인터페이스에서 같은 시그니처를 갖는 메서드를 정의할때는 서브 인터페이스가 이긴다. 즉 B가 A를 상속받는다면 B가A를 이긴다.
- 여전히 디폴트 메서드의 우선순위가 결정되지 않았다면 여러 인터페이스를 상속받는 클래스가 명시적으로 티폴트메서드를 오버하라고 호출해야 한다. 

### 13.4.2 디폴트 메서드를 제공하는 서브 인터페이스가 이긴다. 

- A<- B <- C 이면 B의 메서드 선택 

### 13.4.3 충돌 그리고 명시적인 문제 해결

#### 충돌해결
- 클래스와 메서드 관계로 디폴트 메서드 선택할 수 없는 상황에서는 자바 컴파일러에서 에러발생
- 개발자가 직접 어떤 메서드 사용할지 명시적으로 선택해야함 
```java
public class C implements B,A {
	void hello(){
		B.super.hello();
    }
}
```

### 13.4.4  다이아몬드 문제 
```java
public class Diamond {
  public static void main(String... args) {
    new D().hello();
  }
  static interface A {
    public default void hello() {
      System.out.println("Hello from A");
    }
  }
  static interface B extends A {}
  static interface C extends A {}
  static class D implements B, C {}
}
```
-  A만 디폴트 메서드 있으니 hello from A 출력

- B에도 같은 디폴트 메서드 hello있으면 B 가 선택 
- C에도 있으면 명시적 호출해야 
```java
public interface C extends A {
	void hello(); //추상메서드임. 디폴트 아님. 
}
```
- C는A를 상속 받으니까 C의 추상메서드가 A의 디폴트 메서드보다 우선권 -> 컴파일에러 -> 명시적 선택해야