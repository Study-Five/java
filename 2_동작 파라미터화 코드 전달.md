# 2.동작 파라미터화 코드 전달

- 시시각가 변화는 사용자 요구사항 대응 -> 최소의 엔지니어링 비용, 쉬운 추가기능 구현, 쉬운 유지보수 
- 동작 파라미터화 : 어떻게 실행할 것인지 결정 하지 않은 코드 블록. 나중에 프로그램에서 호출해 실행.
- 메서드의 인수로 코드블록을 전달
  * 리스트의 모든 요소에 대해 '어떤동작'을 수행
  * 리스트 관련 작업 끝난 후 '어떤 다른 동작' 수행
  * 에러가 발생하면 '정해진 동작' 을 수행
    
## 2.1 변화하는 요구사항에 대응하기 

### 2.1.1 첫번째 시도 : 녹색사과 필터링

```java
 public static List<Apple> filterGreenApples(List<Apple> inventory) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
      if (apple.getColor() == Color.GREEN) {
        result.add(apple);
      }
    }
    return result;
  }
```
- 빨간 사과도 필터링 하고 싶으면? -> filterRedApples 새 메서드? ㄴㄴ
- 거의 비슷한 코드가 반복 존재한다면 그 코드를 추상화 한다. 


### 2.1.2 두번째 시도 : 색을 파라미터화 

- 메서드에 색을 받는 파라미터를 추가 
```java
  public static List<Apple> filterApplesByColor(List<Apple> inventory, Color color) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
      if (apple.getColor() == color) {
        result.add(apple);
      }
    }
    return result;
  }

  List<Apple> greenApples = filterApplesByColor(inventory, Color.GREEN);
```

- 무게기준으로 필터하고싶으면? 비슷한 코드에 무게를 파라미터로 
- -> 거의 대부분 코드가 중복, DRY(don't repeat yourself) 원칙 위반.

### 2.1.3 세번쨰 시도 : 가능한 모든 속성으로 필터링 
- 모든 속성을 파라미터로 추가 
- boolean flag 를 받아서 값 또는 무게로 필터링 -> 거지같음

## 2.2 동작 파라미터화 
- 프레디케이트 : 참, 거짓을 반환하는 함수 
```java
  interface ApplePredicate {
    boolean test(Apple a);
  }

static class AppleColorPredicate implements ApplePredicate {
	@Override
	public boolean test(Apple apple) {
		return apple.getColor() == Color.GREEN;
	}
}
```
- 전략 디자인 패턴 : 각 알고리즘을 캡슐화 하는 알고리즘 패밀리를 저 ㅇ의해 둔 후 런타임에 알고리즘 선택. 
- 동작 파라미터화 , 즉 메서드가 다양한 동작(전략)을 받아 내부적으로 다양한 동작 수행 

### 2.2.1 네번째 시도 : 추상적 조건으로 필터링
```java
  public static List<Apple> filter(List<Apple> inventory, ApplePredicate p) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
      if (p.test(apple)) {
        result.add(apple);
      }
    }
    return result;
  }
```
- 코드/동작 전달하기
  * 유연한 코드, 가독성 향상, 사용성 향상
  * 요구사항에 맞는 다양한 predicate 구현해 인자로 넘기면 돼
  * 메서드는 객체만 인수로 받으니, test 메서드를 ApplePredicate객체로 감싸 전달
- 한개의 파라미터, 다양한 동작 
  * 컬렉션 탐색 로직과 적용할 동작의 분리 - 굿
  * 한 메서드가 다른 동작 수행하도록 재활용 가능 
    
## 2.3 복잡한 과정 간소화 
### 2.3.1 익명 클래스 
* 익명클래스 : 지역클래스(블록 내부에 선언된 클래스). 클래스 선언과 동시에 인스턴스화. 즉성에서 필요한 구현해 사용

### 2.3.2 다섯번째 시도 : 익명 클래스 사용
```java
   List<Apple> redApples2 = filter(inventory, new ApplePredicate() {
      @Override
      public boolean test(Apple a) {
        return a.getColor() == Color.RED;
      }
    });
    System.out.println(redApples2);
  }
```
* 여전히 많은 코드공간 차지
* 많은 프로그래머가 익명클래스 사용에 익숙x 
* 결국 객체 생성하고 명시적 동작 정의는 필요함 -> 람다로 해결 가능 
### 2.3.3 여섯번째 시도 : 람다 표현식 사용
```java
List<Apple> result = filterApples(inventory,(Apple apple) -> RED.equals(apple.getColor()));
```
### 2.3.4 일곱번째 시도 : 리스트 형식으로 추상화 
```java
public static <T> List<T> filter(List<T> list, Predicate<T> p) {
  List<T> result = new ArrayList<>();
  for( T e : list){
    if(p.test(e)){
      result.add(e);
    }
  }
  return result;
}
```
* 바나나, 오렌지, 정수, 문자열 리스트에도 필터 메서드 사용 가능 
## 2.4 실전 예제 
### 2.4.1 Comparator로 정렬하기 
* java.util.Comparator 객체 이용해 sort 동작을 파라미터화 가능 
### 2.4.2 Runnerable 로 코드블록 실행하기 
* 스레드 이용해 병렬로 코드 블록 실행할때 각 스레드가 각자 다른 코드 실행하도록. 
* Runnable 인터페이스 사용해 실행할 코드블록 지정
### 2.4.3 GUI 이벤트 처리하기
* ExecutorService 인터페이스는 태스크 제출과 실행 과정의 연관성 끊어줌. 태스크 스레드 풀로 보내고 결과를 Future로 저장
* Callable 인터페이스로 결과 반환하는 태스르 생성 
### 2.4.4 GUI 이벤트 처리하기 
* 자바FX 에서 setOnAction 메서드에 EventHandler 전달해 이벤트 반응 설정 
